<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
    <title>PHP Manual: Data persistence</title>

</head>
<body>
<table width="100%">
    <tr valign="top">
        <td style="font-size: smaller;" width="15%">
<style type="text/css">
#leftbar {
	float: left;
	width: 186px;
	padding: 5px;
	font-size: smaller;
}
ul.toc {
	margin: 0px 5px 5px 5px;
	padding: 0px;
}
ul.toc li {
	font-size: 85%;
	margin: 1px 0 1px 1px;
	padding: 1px 0 1px 11px;
	list-style-type: none;
	background-repeat: no-repeat;
	background-position: center left;
}
ul.toc li.header {
	font-size: 115%;
	padding: 5px 0px 5px 11px;
	border-bottom: 1px solid #cccccc;
	margin-bottom: 5px;
}
ul.toc li.active {
	font-weight: bold;
}
ul.toc li a {
	text-decoration: none;
}
ul.toc li a:hover {
	text-decoration: underline;
}
</style>
 <ul class="toc">
  <li class="header home"><a href="index.html">PHP Manual</a></li>
  <li class="header up"><a href="internals2.html">PHP at the Core: A Hacker's Guide</a></li>
  <li class="header up"><a href="internals2.memory.html">Memory management</a></li>
  <li><a href="internals2.memory.management.html">Basic memory management</a></li>
  <li class="active"><a href="internals2.memory.persistence.html">Data persistence</a></li>
  <li><a href="internals2.memory.tsrm.html">Thread-Safe Resource Manager</a></li>
 </ul>

        </td>
        <td width="85%">
            <div style="text-align: center;">
                <div class="prev" style="text-align: left; float: left;"><a href="internals2.memory.management.html">Basic memory management</a></div>
                <div class="next" style="text-align: right; float: right;"><a href="internals2.memory.tsrm.html">Thread-Safe Resource Manager</a></div>
                <div class="up"><a href="internals2.memory.html">Memory management</a></div>
                <div class="home"><a href="index.html">PHP Manual</a></div>
            </div><hr/>
<div id="internals2.memory.persistence" class="sect1">
 <h2 class="title">Data persistence</h2>
 
 <p class="simpara">
  In this context, data persistence is taken to mean any data that is intended to survive the current request. The memory management within the engine is very focused on request bound allocations, but this is not always practical or appropriate. Persistent memory is sometimes required in order to satisfy requirements of external libraries, it can also be useful while <code class="code">Hacking</code>.
 </p>
 
 <p class="simpara">
  A common use of persistent memory is to enable persistent SQL server connections, though this practice is frowned upon, it is none the less the most common use of this feature.
 </p>
 
 <blockquote class="note"><p><strong class="note">Note</strong>: 
  <span class="simpara">
   All of the following functions take the additional persistent parameter, should this be false, the engine will use its regular allocators (emalloc) and the memory should not be considered persistent. Where memory is allocated as persistent, system allocators are invoked, under most circumstances they are still not able to return NULL pointers just as the Main memory APIs.
  </span>
 </p></blockquote>
 
 <table id="internals2.memory.management.papis" class="doctable table">
  <caption><strong>Persistent memory APIs</strong></caption>
  
   <thead>
    <tr>
     <th>Prototype</th>
     <th>Description</th>
    </tr>

   </thead>

   <tbody class="tbody">
    
    <tr>
     <td><code class="code">void *pemalloc(size_t size, zend_bool persistent)</code></td>
     <td>Allocate <code class="code">size</code> bytes of memory.</td>
    </tr>

    
    <tr>
     <td><code class="code">void *pecalloc(size_t nmemb, size_t size, zend_bool persistent)</code></td>
     <td>
      Allocate a buffer for <code class="code">nmemb</code> elements of
      <code class="code">size</code> bytes and makes sure it is initialized with zeros.
     </td>
    </tr>

    
    <tr>
     <td><code class="code">void *perealloc(void *ptr, size_t size, zend_bool persistent)</code></td>
     <td>
      Resize the buffer <code class="code">ptr</code>, which was allocated using
      <code class="code">emalloc</code> to hold <code class="code">size</code> bytes of memory.
     </td>
    </tr>

    
    <tr>
     <td><code class="code">void pefree(void *ptr, zend_bool persistent)</code></td>
     <td>
      Free the buffer pointed by <code class="code">ptr</code>. The buffer had to be 
      allocated by <code class="code">pemalloc</code>.
     </td>
    </tr>

    
    <tr>
     <td>
      <code class="code">void *safe_pemalloc(size_t nmemb, size_t size, size_t offset, zend_bool persistent)</code>
     </td>
     <td>
      Allocate a buffer for holding <code class="code">nmemb</code> blocks of each
      <code class="code">size</code> bytes and an additional <code class="code">offset</code> bytes.
      This is similar to <code class="code">pemalloc(nmemb * size + offset)</code> but adds
      a special protection against overflows.
     </td>
    </tr>

    
    <tr>
     <td><code class="code">char *pestrdup(const char *s, zend_bool persistent)</code></td>
     <td>
      Allocate a buffer that can hold the NULL-terminated string
      <code class="code">s</code> and copy the <code class="code">s</code> into that buffer.
     </td>
    </tr>

    
    <tr>
     <td>
      <code class="code">char *pestrndup(const char *s, unsigned int length, zend_bool persistent)</code>
     </td>
     <td>
      Similar to <code class="code">pestrdup</code> while the length of the
      NULL-terminated string is already known.
     </td>
    </tr>

   </tbody>
  
 </table>

 
 <div class="caution"><strong class="caution">Caution</strong>
  <p class="simpara">
   It is important to remember that memory allocated to be persistent is not optimized or tracked by the engine; it is not subject to memory_limit, additionally, all variables that are created by the <code class="code">Hacker</code> for the engine must not use persistent memory.
  </p>
 </div>
</div>
        </td>
    </tr>
</table>
</body>
</html>
