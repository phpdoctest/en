<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
    <title>PHP Manual: Recursive patterns</title>

</head>
<body>
<table width="100%">
    <tr valign="top">
        <td style="font-size: smaller;" width="15%">
<style type="text/css">
#leftbar {
	float: left;
	width: 186px;
	padding: 5px;
	font-size: smaller;
}
ul.toc {
	margin: 0px 5px 5px 5px;
	padding: 0px;
}
ul.toc li {
	font-size: 85%;
	margin: 1px 0 1px 1px;
	padding: 1px 0 1px 11px;
	list-style-type: none;
	background-repeat: no-repeat;
	background-position: center left;
}
ul.toc li.header {
	font-size: 115%;
	padding: 5px 0px 5px 11px;
	border-bottom: 1px solid #cccccc;
	margin-bottom: 5px;
}
ul.toc li.active {
	font-weight: bold;
}
ul.toc li a {
	text-decoration: none;
}
ul.toc li a:hover {
	text-decoration: underline;
}
</style>
 <ul class="toc">
  <li class="header home"><a href="index.html">PHP Manual</a></li>
  <li class="header up"><a href="funcref.html">Function Reference</a></li>
  <li class="header up"><a href="refs.basic.text.html">Text Processing</a></li>
  <li class="header up"><a href="book.pcre.html">PCRE</a></li>
  <li class="header up"><a href="pcre.pattern.html">PCRE Patterns</a></li>
  <li class="header up"><a href="reference.pcre.pattern.syntax.html">PCRE regex syntax</a></li>
  <li><a href="regexp.introduction.html">Introduction</a></li>
  <li><a href="regexp.reference.delimiters.html">Delimiters</a></li>
  <li><a href="regexp.reference.meta.html">Meta-characters</a></li>
  <li><a href="regexp.reference.escape.html">Escape sequences</a></li>
  <li><a href="regexp.reference.unicode.html">Unicode character properties</a></li>
  <li><a href="regexp.reference.anchors.html">Anchors</a></li>
  <li><a href="regexp.reference.dot.html">Dot</a></li>
  <li><a href="regexp.reference.character-classes.html">Character classes</a></li>
  <li><a href="regexp.reference.alternation.html">Alternation</a></li>
  <li><a href="regexp.reference.internal-options.html">Internal option setting</a></li>
  <li><a href="regexp.reference.subpatterns.html">Subpatterns</a></li>
  <li><a href="regexp.reference.repetition.html">Repetition</a></li>
  <li><a href="regexp.reference.back-references.html">Back references</a></li>
  <li><a href="regexp.reference.assertions.html">Assertions</a></li>
  <li><a href="regexp.reference.onlyonce.html">Once-only subpatterns</a></li>
  <li><a href="regexp.reference.conditional.html">Conditional subpatterns</a></li>
  <li><a href="regexp.reference.comments.html">Comments</a></li>
  <li class="active"><a href="regexp.reference.recursive.html">Recursive patterns</a></li>
  <li><a href="regexp.reference.performance.html">Performance</a></li>
 </ul>

        </td>
        <td width="85%">
            <div style="text-align: center;">
                <div class="prev" style="text-align: left; float: left;"><a href="regexp.reference.comments.html">Comments</a></div>
                <div class="next" style="text-align: right; float: right;"><a href="regexp.reference.performance.html">Performance</a></div>
                <div class="up"><a href="reference.pcre.pattern.syntax.html">PCRE regex syntax</a></div>
                <div class="home"><a href="index.html">PHP Manual</a></div>
            </div><hr/>
<div id="regexp.reference.recursive" class="section">
  <h2 class="title">Recursive patterns</h2>
  <p class="para">
   Consider the problem of matching a  string  in  parentheses,
   allowing  for  unlimited nested parentheses. Without the use
   of recursion, the best that can be done is to use a  pattern
   that  matches  up  to some fixed depth of nesting. It is not
   possible to handle an arbitrary nesting depth. Perl 5.6  has
   provided   an  experimental  facility  that  allows  regular
   expressions to recurse (among other things).  The  special
   item (?R) is  provided for  the specific  case of recursion.
   This PCRE  pattern  solves the  parentheses  problem (assume
   the <a href="reference.pcre.pattern.modifiers.html" class="link">PCRE_EXTENDED</a>
   option is set so that white space is
   ignored):

   <em>\( ( (?&gt;[^()]+) | (?R) )* \)</em>
  </p>
  <p class="para">
   First it matches an opening parenthesis. Then it matches any
   number  of substrings which can either be a sequence of
   non-parentheses, or a recursive  match  of  the  pattern  itself
   (i.e. a correctly parenthesized substring). Finally there is
   a closing parenthesis.
  </p>
  <p class="para">
   This particular example pattern  contains  nested  unlimited
   repeats, and so the use of a once-only subpattern for matching
   strings of non-parentheses is  important  when  applying
   the  pattern to strings that do not match. For example, when
   it is applied to

   <em>(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()</em>

   it yields &quot;no match&quot; quickly. However, if a  once-only  subpattern
   is  not  used,  the match runs for a very long time
   indeed because there are so many different ways the + and  *
   repeats  can carve up the subject, and all have to be tested
   before failure can be reported.
  </p>
  <p class="para">
   The values set for any capturing subpatterns are those  from
   the outermost level of the recursion at which the subpattern
   value is set. If the pattern above is matched against

   <em>(ab(cd)ef)</em>

   the value for the capturing parentheses is  &quot;ef&quot;,  which  is
   the  last  value  taken  on  at the top level. If additional
   parentheses are added, giving

   <em>\( ( ( (?&gt;[^()]+) | (?R) )* ) \)</em>
   then the string they capture
   is &quot;ab(cd)ef&quot;, the contents of the top level parentheses. If
   there are more than 15 capturing parentheses in  a  pattern,
   PCRE  has  to  obtain  extra  memory  to store data during a
   recursion, which it does by using  pcre_malloc,  freeing  it
   via  pcre_free  afterwards. If no memory can be obtained, it
   saves data for the first 15 capturing parentheses  only,  as
   there is no way to give an out-of-memory error from within a
   recursion.
  </p>

  <p class="para">
   <em>(?1)</em>, <em>(?2)</em> and so on
   can be used for recursive subpatterns too. It is also possible to use named
   subpatterns: <em>(?P&gt;name)</em> or
   <em>(?&amp;name)</em>.
  </p>
  <p class="para">
   If the syntax for a recursive subpattern reference (either by number or
   by name) is used outside the parentheses to which it refers, it operates
   like a subroutine in a programming language. An earlier example
   pointed out that the pattern
   <em>(sens|respons)e and \1ibility</em>
   matches &quot;sense and sensibility&quot; and &quot;response and responsibility&quot;, but
   not &quot;sense and responsibility&quot;. If instead the pattern
   <em>(sens|respons)e and (?1)ibility</em>
   is used, it does match &quot;sense and responsibility&quot; as well as the other
   two strings. Such references must, however, follow the subpattern to
   which they refer.
  </p>

  <p class="para">
   The maximum length of a subject string is the largest positive number
   that an integer variable can hold. However, PCRE uses recursion to
   handle subpatterns and indefinite repetition. This means that the
   available stack space may limit the size of a subject string that can be
   processed by certain patterns.
  </p>

 </div>
        </td>
    </tr>
</table>
</body>
</html>
